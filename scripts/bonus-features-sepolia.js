// File: scripts/bonus-features-sepolia.js
const { ethers } = require("hardhat");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
require("dotenv").config();

/**
 * BONUS: Remote Attestation & View Key Implementation on Sepolia
 * This file demonstrates the concepts of:
 * 1. Remote attestation of a TEE (Trusted Execution Environment)
 * 2. View key implementation for controlled access to decrypted data
 * 
 * All of this happens with a real transaction on Sepolia testnet
 */

// Get the deployed contract address
function getDeployedContractAddress() {
  try {
    return fs.readFileSync(
      path.join(__dirname, "../.sepolia-contract-address"),
      "utf8"
    ).trim();
  } catch (error) {
    throw new Error("Contract address file not found. Please deploy the contract first using 'npx hardhat run scripts/deploy-sepolia.js --network sepolia'");
  }
}

// ========= SIMULATED TEE FUNCTIONS =========

// Mock TEE identity
const mockTee = {
  enclaveId: "0x" + crypto.randomBytes(16).toString("hex"),
  teeType: "INTEL_SGX",
  mrEnclave: "0x" + crypto.randomBytes(32).toString("hex"),
  mrSigner: "0x" + crypto.randomBytes(32).toString("hex"),
  privateKey: crypto.randomBytes(32)
};

// Generate mock attestation report
function generateAttestationReport() {
  // In a real implementation this would be generated by the TEE platform
  const report = {
    enclaveId: mockTee.enclaveId,
    teeType: mockTee.teeType,
    mrEnclave: mockTee.mrEnclave,
    mrSigner: mockTee.mrSigner,
    timestamp: Date.now(),
    securityVersion: "2.0",
    attributes: {
      debug: false,
      isInitializer: true,
      mode64bit: true
    }
  };
  
  // Simulate a signature (in real implementation this would be a proper cryptographic signature)
  const reportJson = JSON.stringify(report);
  const reportHash = crypto.createHash('sha256').update(reportJson).digest('hex');
  const mockSignature = crypto.createHash('sha256').update(reportHash + mockTee.privateKey.toString('hex')).digest('hex');
  
  return {
    report,
    signature: "0x" + mockSignature
  };
}

// ========= VIEW KEY IMPLEMENTATION =========

// Generate a view key for a specific user
function generateViewKey(userAddress) {
  // In real implementation, this would be derived in the TEE
  // and would likely involve some form of key agreement protocol
  const viewKeyBytes = crypto.randomBytes(32);
  const viewKey = "0x" + viewKeyBytes.toString("hex");
  
  return {
    userAddress,
    viewKey,
    expiry: Date.now() + 86400000 // 24 hours
  };
}

// Simple symmetric encryption simulation (using XOR for demonstration)
function encryptData(data, viewKey) {
  // Convert data to string if it's not already
  const dataStr = typeof data === 'string' ? data : JSON.stringify(data);
  // Convert to buffer
  const dataBuffer = Buffer.from(dataStr);
  // Get key bytes (remove 0x prefix)
  const keyBytes = Buffer.from(viewKey.slice(2), 'hex');
  
  // Simple XOR encryption (for demonstration only - not secure!)
  const encrypted = Buffer.alloc(dataBuffer.length);
  for (let i = 0; i < dataBuffer.length; i++) {
    encrypted[i] = dataBuffer[i] ^ keyBytes[i % keyBytes.length];
  }
  
  return encrypted.toString('base64');
}

// Simple decryption using the view key
function decryptData(encryptedData, viewKey) {
  try {
    // Get encrypted data as buffer
    const dataBuffer = Buffer.from(encryptedData, 'base64');
    // Get key bytes (remove 0x prefix)
    const keyBytes = Buffer.from(viewKey.slice(2), 'hex');
    
    // Simple XOR decryption
    const decrypted = Buffer.alloc(dataBuffer.length);
    for (let i = 0; i < dataBuffer.length; i++) {
      decrypted[i] = dataBuffer[i] ^ keyBytes[i % keyBytes.length];
    }
    
    // Parse as JSON if possible
    return JSON.parse(decrypted.toString());
  } catch (error) {
    console.error("Decryption failed:", error.message);
    return null;
  }
}

// Simulate decryption of private data with view key check
function decryptWithViewKey(encryptedPayload, providedViewKey, userViewKey) {
  // Check if view key matches and is valid
  if (providedViewKey !== userViewKey.viewKey) {
    throw new Error("Invalid view key");
  }
  
  if (Date.now() > userViewKey.expiry) {
    throw new Error("View key has expired");
  }
  
  // Decrypt the payload with the provided view key
  const decryptedData = decryptData(encryptedPayload, providedViewKey);
  
  return {
    decryptedData,
    viewKeyUsed: providedViewKey,
    decryptedAt: new Date().toISOString()
  };
}

// ========= DEMO ON SEPOLIA =========

async function main() {
  console.log("==== BONUS: REMOTE ATTESTATION & VIEW KEY DEMO ON SEPOLIA ====\n");
  
  // Get contract address
  const contractAddress = process.env.CONTRACT_ADDRESS || getDeployedContractAddress();
  console.log(`Using contract at: ${contractAddress}`);
  
  // Get signer 
  const [signer] = await ethers.getSigners();
  const signerAddress = await signer.getAddress();
  console.log(`Connected with address: ${signerAddress}\n`);
  
  // Connect to the deployed contract
  const PrivateTransferVault = await ethers.getContractFactory("PrivateTransferVault");
  const vault = PrivateTransferVault.attach(contractAddress);
  
  // 1. Generate and verify attestation report
  console.log("1️⃣ GENERATING TEE REMOTE ATTESTATION");
  const attestation = generateAttestationReport();
  console.log("   Attestation report generated:");
  console.log(`   - Enclave ID: ${attestation.report.enclaveId}`);
  console.log(`   - TEE Type: ${attestation.report.teeType}`);
  console.log(`   - Security Version: ${attestation.report.securityVersion}`);
  console.log(`   - Signature: ${attestation.signature.substring(0, 30)}...`);
  
  // Simulate verification of attestation
  console.log("\n   Verifying TEE attestation...");
  console.log("   ✅ TEE attestation verified (simulated)");
  
  // 2. Create a transfer with real data
  console.log("\n2️⃣ CREATING PRIVATE TRANSFER ON SEPOLIA");
  const transferPayload = {
    sender: "0x24776C87d7DF39D3Bb2f4ACcAbE8640B650910DB", // Example sender
    recipient: "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC", // Example recipient
    amount: ethers.utils.parseEther("0.001").toString(),
    timestamp: Date.now()
  };
  console.log(`   Transfer Details:`);
  console.log(`   - From: ${transferPayload.sender}`);
  console.log(`   - To: ${transferPayload.recipient}`);
  console.log(`   - Amount: ${ethers.utils.formatEther(transferPayload.amount)} ETH`);
  
  // 3. Generate view key for the sender
  console.log("\n3️⃣ GENERATING VIEW KEY FOR USER");
  const userViewKey = generateViewKey(signerAddress);
  console.log(`   View key generated for: ${userViewKey.userAddress}`);
  console.log(`   View key: ${userViewKey.viewKey.substring(0, 10)}...`); 
  console.log(`   Expires: ${new Date(userViewKey.expiry).toISOString()}`);
  
  // 4. Encrypt the transfer data with the view key
  console.log("\n4️⃣ ENCRYPTING TRANSFER DATA WITH VIEW KEY");
  const encryptedData = encryptData(transferPayload, userViewKey.viewKey);
  console.log(`   Encrypted payload: ${encryptedData.substring(0, 40)}...`);
  console.log("   This encrypted data would be stored off-chain in a real implementation");
  
  // 5. Generate and submit commitment to Sepolia
  console.log("\n5️⃣ SUBMITTING COMMITMENT TO SEPOLIA BLOCKCHAIN");
  const abiCoder = ethers.utils.defaultAbiCoder;
  const encoded = abiCoder.encode(
    ["address", "address", "uint256", "uint256"],
    [transferPayload.sender, transferPayload.recipient, transferPayload.amount, transferPayload.timestamp]
  );
  const commitment = ethers.utils.keccak256(encoded);
  console.log(`   Generated commitment: ${commitment}`);
  
  // Submit the transaction to Sepolia
  console.log("   Sending transaction to Sepolia...");
  const tx = await vault.submitTransfer(commitment);
  console.log(`   Transaction hash: ${tx.hash}`);
  console.log(`   View on Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
  
  // Wait for transaction confirmation
  console.log("   Waiting for transaction confirmation...");
  const receipt = await tx.wait();
  console.log(`   ✅ Transaction confirmed in block #${receipt.blockNumber}`);
  
  // 6. Simulate access with view key
  console.log("\n6️⃣ DEMONSTRATING VIEW KEY ACCESS");
  
  // Try valid view key
  console.log("   Attempting decryption with valid view key:");
  try {
    const result = decryptWithViewKey(
      encryptedData,
      userViewKey.viewKey,
      userViewKey
    );
    console.log("   ✅ Decryption successful!");
    console.log(`   Decrypted at: ${result.decryptedAt}`);
    console.log(`   Transaction details:`);
    console.log(`   - From: ${result.decryptedData.sender}`);
    console.log(`   - To: ${result.decryptedData.recipient}`);
    console.log(`   - Amount: ${ethers.utils.formatEther(result.decryptedData.amount)} ETH`);
  } catch (error) {
    console.log(`   ❌ Decryption failed: ${error.message}`);
  }
  
  // Try invalid view key
  console.log("\n   Attempting decryption with invalid view key:");
  try {
    const invalidViewKey = "0x" + crypto.randomBytes(32).toString("hex");
    const result = decryptWithViewKey(
      encryptedData,
      invalidViewKey,
      userViewKey
    );
    console.log("   Unexpected success - should have failed");
  } catch (error) {
    console.log(`   ❌ Decryption failed: ${error.message} (as expected)`);
  }
  
  console.log("\n✨ BONUS FEATURES SUMMARY:");
  console.log("1. Remote attestation ensures the relayer code integrity");
  console.log("2. View keys provide selective disclosure of private transaction data");
  console.log("3. Only commitments are visible on-chain (check Etherscan)");
  console.log("4. Actual transaction details can only be accessed with the correct view key");
  console.log("");
  console.log(`View your transaction on Etherscan: https://sepolia.etherscan.io/tx/${tx.hash}`);
  console.log("");
}

// Execute the script
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error("Error:", error);
    process.exit(1);
  });
